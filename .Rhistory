corrplot::corrplot(corr = as.matrix(correlations))
library(car)
# somemodel
RandomModel <- lm(VV ~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns)
summary(RandomModel)
vifrandom <- as.data.frame(sort(car::vif(RandomModel),decreasing = T))
vifrandom$Model <- "Arbitary model"
vifrandom$Predictors <- row.names(vifrandom)
colnames(vifrandom) <- c("VIF", "Model", "Predictors")
# fullmodel
form <- paste0(colnames(correlations)[-21],collapse = "+")
fullmodel <- lm(VV~., data = returns)
summary(fullmodel)
viffm <- as.data.frame(sort(car::vif(fullmodel), decreasing = T))
viffm$Model <- "Full Model"
viffm$Predictors <- row.names(viffm)
colnames(viffm) <- c("VIF", "Model","Predictors")
VIF <- rbind(vifrandom, viffm, row.names = F)
VIFReport <- VIF[1:nrow(VIF)-1,] %>% dplyr::group_by(Model) %>%
dplyr::top_n(n =5,wt = VIF)
VIFReport <- VIFReport[,c("Model","Predictors","VIF")]
knitr::kable(VIFReport, format = "latex",caption = "VIF Full model") %>%
kableExtra::kable_styling(latex_options = "striped") %>%
kableExtra::collapse_rows(columns = 1)
returns.pca <- princomp(returns[,-21], cor = T)
pc.1 <- returns.pca$loadings[,1]
pc.2 <- returns.pca$loadings[,2]
pcs <- data.frame(pc.1,pc.2,names(pc.1))
colnames(pcs) <- c("PC1","PC2","Index")
pcs$Industry <- c("Indus Metal"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Industrial Chemical"
, "Industrial Chemical"
, "Soft Drinks"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Manufacturing"
, "Industrial Chemical"
, "Banking"
, "Soft Drinks"
, "Manufacuring"
, "Oil Refining"
,"Soft Drinks"
, "Oil Field Services"
, "Banking"
, "Oil Refining"
)
ggplot(data = pcs,mapping = aes(x = PC1,y = PC2,label = Index,color = Industry)) + geom_point() + geom_text(size = 3) + theme_bw() + xlim(c(-0.27,-0.12)) + ylim(c(-0.27,0.6))
plot(returns.pca, xlab = "Component Number", main = " ")
# screeplot(returns.pca)
varcontribution <- returns.pca$sdev^2 / sum(returns.pca$sdev^2)
plot(varcontribution, xlab = "Component Number", ylab = "Variance Contribution", type = "l")
points(varcontribution)
cumvariance <- cumsum(returns.pca$sdev^2) / sum(returns.pca$sdev^2)
plot(cumvariance, xlab = "Component Number", ylab = "Cumulative Variance", type = "l")
points(cumvariance)
abline(h=0.8,lwd = 1.5,col = "red")
abline(v = 8,lwd = 1.5, col = "red")
text(13,0.7, 'Keep 8 Principal Components')
returns.scores <- as.data.frame(returns.pca$scores)
returns.scores$VV <- returns$VV
returns.scores$u <- runif(n = nrow(returns.scores), min = 0, max = 1)
train.scores <- subset(returns.scores,u < 0.7)
test.scores <- subset(returns.scores, u >= 0.7)
df <- cbind(Data = c("Training set", "Validation set","Total"), Samples = c(nrow(train.scores),nrow(test.scores),nrow(train.scores) + nrow(test.scores)))
knitr::kable(df,align = c("l","r"),caption = "Training and Validation sampling")
pca.lm <- lm(VV ~ Comp.1 + Comp.2 + Comp.3 + Comp.4 + Comp.5 + Comp.6 + Comp.7 + Comp.8, data = returns.scores)
summary(pca.lm)
vifpc <- as.data.frame(vif(pca.lm))
vifpc$PC <- row.names(vifpc)
colnames(vifpc) <- c("VIF", "PC")
row.names(vifpc) <- NULL
knitr::kable(vifpc[,c("PC","VIF")], caption = "VIF of Principle components")
knitr::opts_chunk$set(echo = F,tidy.opts=list(width.cutoff=70),tidy=TRUE)
library(magrittr)
library(ggplot2)
# read data in
stocks <- read.csv(file = 'stock_portfolio.csv', header = T)
# format date & sort chronologically
stocks$Date <- as.Date(stocks$Date,'%d -%b-%y')
stocks <- stocks %>%
dplyr::arrange(Date)
# get log-returns of the data
logreturns <- function(x) {
log(x[-1]/x[-length(x)])
}
returns <- purrr::map_df(.x = stocks[,-1], .f = logreturns)
# compute correlations table
correlations <- as.data.frame(cor(returns))
# get only VV
library(ggplot2)
library(forcats)
VV_cor <- as.data.frame(correlations$VV[-nrow(correlations)])
colnames(VV_cor) <- "VV"
rownames(VV_cor) <- rownames(correlations)[-21]
ggplot(data = VV_cor, mapping = aes(x = fct_reorder(rownames(VV_cor),VV), y = VV)) + geom_col() + coord_flip() + xlab("Stock Index") + ylab("Correlation")
#+ ggtitle ("                                       Correlations with VV")
corrplot::corrplot(corr = as.matrix(correlations))
library(car)
# somemodel
RandomModel <- lm(VV ~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns)
summary(RandomModel)
vifrandom <- as.data.frame(sort(car::vif(RandomModel),decreasing = T))
vifrandom$Model <- "Arbitary model"
vifrandom$Predictors <- row.names(vifrandom)
colnames(vifrandom) <- c("VIF", "Model", "Predictors")
# fullmodel
form <- paste0(colnames(correlations)[-21],collapse = "+")
fullmodel <- lm(VV~., data = returns)
summary(fullmodel)
viffm <- as.data.frame(sort(car::vif(fullmodel), decreasing = T))
viffm$Model <- "Full Model"
viffm$Predictors <- row.names(viffm)
colnames(viffm) <- c("VIF", "Model","Predictors")
VIF <- rbind(vifrandom, viffm, row.names = F)
VIFReport <- VIF[1:nrow(VIF)-1,] %>% dplyr::group_by(Model) %>%
dplyr::top_n(n =5,wt = VIF)
VIFReport <- VIFReport[,c("Model","Predictors","VIF")]
knitr::kable(VIFReport, format = "latex",caption = "VIF Full model") %>%
kableExtra::kable_styling(latex_options = "striped") %>%
kableExtra::collapse_rows(columns = 1)
returns.pca <- princomp(returns[,-21], cor = T)
pc.1 <- returns.pca$loadings[,1]
pc.2 <- returns.pca$loadings[,2]
pcs <- data.frame(pc.1,pc.2,names(pc.1))
colnames(pcs) <- c("PC1","PC2","Index")
pcs$Industry <- c("Indus Metal"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Industrial Chemical"
, "Industrial Chemical"
, "Soft Drinks"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Manufacturing"
, "Industrial Chemical"
, "Banking"
, "Soft Drinks"
, "Manufacuring"
, "Oil Refining"
,"Soft Drinks"
, "Oil Field Services"
, "Banking"
, "Oil Refining"
)
ggplot(data = pcs,mapping = aes(x = PC1,y = PC2,label = Index,color = Industry)) + geom_point() + geom_text(size = 3) + theme_bw() + xlim(c(-0.27,-0.12)) + ylim(c(-0.27,0.6))
plot(returns.pca, xlab = "Component Number", main = " ")
# screeplot(returns.pca)
varcontribution <- returns.pca$sdev^2 / sum(returns.pca$sdev^2)
plot(varcontribution, xlab = "Component Number", ylab = "Variance Contribution", type = "l")
points(varcontribution)
cumvariance <- cumsum(returns.pca$sdev^2) / sum(returns.pca$sdev^2)
plot(cumvariance, xlab = "Component Number", ylab = "Cumulative Variance", type = "l")
points(cumvariance)
abline(h=0.8,lwd = 1.5,col = "red")
abline(v = 8,lwd = 1.5, col = "red")
text(13,0.7, 'Keep 8 Principal Components')
returns.scores <- as.data.frame(returns.pca$scores)
returns.scores$VV <- returns$VV
returns.scores$u <- runif(n = nrow(returns.scores), min = 0, max = 1)
train.scores <- subset(returns.scores,u < 0.7)
test.scores <- subset(returns.scores, u >= 0.7)
df <- cbind(Data = c("Training set", "Validation set","Total"), Samples = c(nrow(train.scores),nrow(test.scores),nrow(train.scores) + nrow(test.scores)))
knitr::kable(df,align = c("l","r"),caption = "Training and Validation sampling")
pca.lm <- lm(VV ~ Comp.1 + Comp.2 + Comp.3 + Comp.4 + Comp.5 + Comp.6 + Comp.7 + Comp.8, data = returns.scores)
summary(pca.lm)
vifpc <- as.data.frame(vif(pca.lm))
vifpc$PC <- row.names(vifpc)
colnames(vifpc) <- c("VIF", "PC")
row.names(vifpc) <- NULL
knitr::kable(vifpc[,c("PC","VIF")], caption = "VIF of Principle components")
pca.lm.MAE <- mean(abs(pca.lm$residuals))
pca.test <- predict(pca.lm,newdata = test.scores)
pca.test.MAE <- mean(abs(test.scores$VV - pca.test))
coef_pca <- round(coef(pca.lm),5)
signs_pca <- ifelse(sign(coef_pca)==1,"+","-")
formula_pca <- as.character(formula(pca.lm))[3]
predictors_pca <- unlist(strsplit(formula_pca, split = "+",fixed = T))
Betas_pca <- paste(abs(coef_pca[2:length(coef_pca)]),"*", predictors_pca)
pcaeqn <- paste("VV = ",paste(coef_pca[1],paste(paste(signs_pca[2:length(signs_pca)], Betas_pca),collapse = " ")))
returns$u <- runif(nrow(returns), min = 0 , max = 1)
returns.train <- subset(returns,u >= 0.7)
returns.test <- subset(returns, u < 0.7)
df <- cbind(Data = c("Training set", "Validation set","Total"), Samples = c(nrow(returns.train),nrow(returns.test),nrow(returns.train) + nrow(returns.test)))
knitr::kable(df,align = c("l","r"),caption = "Training and Validation sampling of Raw returns")
model.1 <- lm(VV~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns.train)
summary(model.1)
coef_model.1 <- round(coef(model.1),5)
signs_model.1 <- ifelse(sign(coef_model.1)==1,"+","-")
formula_model.1 <- as.character(formula(model.1))[3]
predictors_model.1 <- unlist(strsplit(formula_model.1, split = "+",fixed = T))
Betas_model.1 <- paste(abs(coef_model.1[2:length(coef_model.1)]),"*", predictors_model.1)
model.1eqn <- paste("VV = ",paste(coef_model.1[1],paste(paste(signs_model.1[2:length(signs_model.1)], Betas_model.1),collapse = " ")))
model1.train.MAE <- mean(abs(model.1$residuals))
model1.test <- predict(model.1, newdata = returns.test)
model1.test.MAE <- mean(abs(model1.test - returns.test$VV))
knitr::opts_chunk$set(echo = F,tidy.opts=list(width.cutoff=70),tidy=TRUE)
library(magrittr)
library(ggplot2)
# read data in
stocks <- read.csv(file = 'stock_portfolio.csv', header = T)
# format date & sort chronologically
stocks$Date <- as.Date(stocks$Date,'%d -%b-%y')
stocks <- stocks %>%
dplyr::arrange(Date)
# get log-returns of the data
logreturns <- function(x) {
log(x[-1]/x[-length(x)])
}
returns <- purrr::map_df(.x = stocks[,-1], .f = logreturns)
# compute correlations table
correlations <- as.data.frame(cor(returns))
# get only VV
library(ggplot2)
library(forcats)
VV_cor <- as.data.frame(correlations$VV[-nrow(correlations)])
colnames(VV_cor) <- "VV"
rownames(VV_cor) <- rownames(correlations)[-21]
ggplot(data = VV_cor, mapping = aes(x = fct_reorder(rownames(VV_cor),VV), y = VV)) + geom_col() + coord_flip() + xlab("Stock Index") + ylab("Correlation")
#+ ggtitle ("                                       Correlations with VV")
corrplot::corrplot(corr = as.matrix(correlations))
library(car)
# somemodel
RandomModel <- lm(VV ~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns)
summary(RandomModel)
vifrandom <- as.data.frame(sort(car::vif(RandomModel),decreasing = T))
vifrandom$Model <- "Arbitary model"
vifrandom$Predictors <- row.names(vifrandom)
colnames(vifrandom) <- c("VIF", "Model", "Predictors")
# fullmodel
form <- paste0(colnames(correlations)[-21],collapse = "+")
fullmodel <- lm(VV~., data = returns)
summary(fullmodel)
viffm <- as.data.frame(sort(car::vif(fullmodel), decreasing = T))
viffm$Model <- "Full Model"
viffm$Predictors <- row.names(viffm)
colnames(viffm) <- c("VIF", "Model","Predictors")
VIF <- rbind(vifrandom, viffm, row.names = F)
VIFReport <- VIF[1:nrow(VIF)-1,] %>% dplyr::group_by(Model) %>%
dplyr::top_n(n =5,wt = VIF)
VIFReport <- VIFReport[,c("Model","Predictors","VIF")]
knitr::kable(VIFReport, format = "latex",caption = "VIF Full model") %>%
kableExtra::kable_styling(latex_options = "striped") %>%
kableExtra::collapse_rows(columns = 1)
returns.pca <- princomp(returns[,-21], cor = T)
pc.1 <- returns.pca$loadings[,1]
pc.2 <- returns.pca$loadings[,2]
pcs <- data.frame(pc.1,pc.2,names(pc.1))
colnames(pcs) <- c("PC1","PC2","Index")
pcs$Industry <- c("Indus Metal"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Industrial Chemical"
, "Industrial Chemical"
, "Soft Drinks"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Manufacturing"
, "Industrial Chemical"
, "Banking"
, "Soft Drinks"
, "Manufacuring"
, "Oil Refining"
,"Soft Drinks"
, "Oil Field Services"
, "Banking"
, "Oil Refining"
)
ggplot(data = pcs,mapping = aes(x = PC1,y = PC2,label = Index,color = Industry)) + geom_point() + geom_text(size = 3) + theme_bw() + xlim(c(-0.27,-0.12)) + ylim(c(-0.27,0.6))
plot(returns.pca, xlab = "Component Number", main = " ")
# screeplot(returns.pca)
varcontribution <- returns.pca$sdev^2 / sum(returns.pca$sdev^2)
plot(varcontribution, xlab = "Component Number", ylab = "Variance Contribution", type = "l")
points(varcontribution)
cumvariance <- cumsum(returns.pca$sdev^2) / sum(returns.pca$sdev^2)
plot(cumvariance, xlab = "Component Number", ylab = "Cumulative Variance", type = "l")
points(cumvariance)
abline(h=0.8,lwd = 1.5,col = "red")
abline(v = 8,lwd = 1.5, col = "red")
text(13,0.7, 'Keep 8 Principal Components')
returns.scores <- as.data.frame(returns.pca$scores)
returns.scores$VV <- returns$VV
returns.scores$u <- runif(n = nrow(returns.scores), min = 0, max = 1)
train.scores <- subset(returns.scores,u < 0.7)
test.scores <- subset(returns.scores, u >= 0.7)
df <- cbind(Data = c("Training set", "Validation set","Total"), Samples = c(nrow(train.scores),nrow(test.scores),nrow(train.scores) + nrow(test.scores)))
knitr::kable(df,align = c("l","r"),caption = "Training and Validation sampling")
pca.lm <- lm(VV ~ Comp.1 + Comp.2 + Comp.3 + Comp.4 + Comp.5 + Comp.6 + Comp.7 + Comp.8, data = returns.scores)
summary(pca.lm)
vifpc <- as.data.frame(vif(pca.lm))
vifpc$PC <- row.names(vifpc)
colnames(vifpc) <- c("VIF", "PC")
row.names(vifpc) <- NULL
knitr::kable(vifpc[,c("PC","VIF")], caption = "VIF of Principle components")
pca.lm.MAE <- mean(abs(pca.lm$residuals))
pca.test <- predict(pca.lm,newdata = test.scores)
pca.test.MAE <- mean(abs(test.scores$VV - pca.test))
coef_pca <- round(coef(pca.lm),5)
signs_pca <- ifelse(sign(coef_pca)==1,"+","-")
formula_pca <- as.character(formula(pca.lm))[3]
predictors_pca <- unlist(strsplit(formula_pca, split = "+",fixed = T))
Betas_pca <- paste(abs(coef_pca[2:length(coef_pca)]),"*", predictors_pca)
pcaeqn <- paste("VV = ",paste(coef_pca[1],paste(paste(signs_pca[2:length(signs_pca)], Betas_pca),collapse = " ")))
returns$u <- runif(nrow(returns), min = 0 , max = 1)
returns.train <- subset(returns,u >= 0.7)
returns.test <- subset(returns, u < 0.7)
df <- cbind(Data = c("Training set", "Validation set","Total"), Samples = c(nrow(returns.train),nrow(returns.test),nrow(returns.train) + nrow(returns.test)))
knitr::kable(df,align = c("l","r"),caption = "Training and Validation sampling of Raw returns")
model.1 <- lm(VV~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns.train)
summary(model.1)
coef_model.1 <- round(coef(model.1),5)
signs_model.1 <- ifelse(sign(coef_model.1)==1,"+","-")
formula_model.1 <- as.character(formula(model.1))[3]
predictors_model.1 <- unlist(strsplit(formula_model.1, split = "+",fixed = T))
Betas_model.1 <- paste(abs(coef_model.1[2:length(coef_model.1)]),"*", predictors_model.1)
model.1eqn <- paste("VV = ",paste(coef_model.1[1],paste(paste(signs_model.1[2:length(signs_model.1)], Betas_model.1),collapse = " ")))
model1.train.MAE <- mean(abs(model.1$residuals))
model1.test <- predict(model.1, newdata = returns.test)
model1.test.MAE <- mean(abs(model1.test - returns.test$VV))
ModelComp <- rbind(MAEdf,ArbMAEdf,FullMAEdf)
summary(model.2)
#model.1 <- lm(VV~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns.train)
summary(model.1)
model1.train.MAE <- mean(abs(model.1$residuals))
model1.test <- predict(model.1, newdata = returns.test)
model1.test.MAE <- mean(abs(model1.test - returns.test$VV))
ArbMAEdf <- data.frame(Model = "Arbitary model", Train.MAE = model1.train.MAE, Test.MAE = model1.test.MAE)
knitr::kable(ArbMAEdf, caption = "MAE of Arbitary model")
# full model
model.2 <- lm(VV~ ., data = returns.train)
coef_model.2 <- round(coef(model.2),5)
signs_model.2 <- ifelse(sign(coef_model.2)==1,"+","-")
formula_model.2 <- as.character(formula(model.2))[3]
predictors_model.2 <- unlist(strsplit(formula_model.2, split = "+",fixed = T))
Betas_model.2 <- paste(abs(coef_model.2[2:length(coef_model.2)]),"*", predictors_model.2)
model.2eqn <- paste("VV = ",paste(coef_model.2[1],paste(paste(signs_model.2[2:length(signs_model.2)], Betas_model.2),collapse = " ")))
summary(model.2)
model2.train.MAE <- mean(abs(model.2$residuals))
model2.test <- predict(model.2, newdata = returns.test)
model2.test.MAE <- mean(abs(model2.test - returns.test$VV))
FullMAEdf <- data.frame(Model = "Full model", Train.MAE = model2.train.MAE, Test.MAE = model2.test.MAE)
knitr::kable(FullMAEdf, caption = "MAE of Full model")
models <- data.frame(Models = c("PCA","Arbitary","Full"), Equation = c(pcaeqn,model.1eqn,model.2eqn))
pander::pandoc.table(models, "Model equations",justify = "left",emphasixe.cols = 2)
ModelComp <- rbind(MAEdf,ArbMAEdf,FullMAEdf)
knitr::opts_chunk$set(echo = F,tidy.opts=list(width.cutoff=70),tidy=TRUE)
library(magrittr)
library(ggplot2)
# read data in
stocks <- read.csv(file = 'stock_portfolio.csv', header = T)
# format date & sort chronologically
stocks$Date <- as.Date(stocks$Date,'%d -%b-%y')
stocks <- stocks %>%
dplyr::arrange(Date)
# get log-returns of the data
logreturns <- function(x) {
log(x[-1]/x[-length(x)])
}
returns <- purrr::map_df(.x = stocks[,-1], .f = logreturns)
# compute correlations table
correlations <- as.data.frame(cor(returns))
# get only VV
library(ggplot2)
library(forcats)
VV_cor <- as.data.frame(correlations$VV[-nrow(correlations)])
colnames(VV_cor) <- "VV"
rownames(VV_cor) <- rownames(correlations)[-21]
ggplot(data = VV_cor, mapping = aes(x = fct_reorder(rownames(VV_cor),VV), y = VV)) + geom_col() + coord_flip() + xlab("Stock Index") + ylab("Correlation")
#+ ggtitle ("                                       Correlations with VV")
corrplot::corrplot(corr = as.matrix(correlations))
library(car)
# somemodel
RandomModel <- lm(VV ~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns)
summary(RandomModel)
vifrandom <- as.data.frame(sort(car::vif(RandomModel),decreasing = T))
vifrandom$Model <- "Arbitary model"
vifrandom$Predictors <- row.names(vifrandom)
colnames(vifrandom) <- c("VIF", "Model", "Predictors")
# fullmodel
form <- paste0(colnames(correlations)[-21],collapse = "+")
fullmodel <- lm(VV~., data = returns)
summary(fullmodel)
viffm <- as.data.frame(sort(car::vif(fullmodel), decreasing = T))
viffm$Model <- "Full Model"
viffm$Predictors <- row.names(viffm)
colnames(viffm) <- c("VIF", "Model","Predictors")
VIF <- rbind(vifrandom, viffm, row.names = F)
VIFReport <- VIF[1:nrow(VIF)-1,] %>% dplyr::group_by(Model) %>%
dplyr::top_n(n =5,wt = VIF)
VIFReport <- VIFReport[,c("Model","Predictors","VIF")]
knitr::kable(VIFReport, format = "latex",caption = "Top 5 VIF by model") %>%
kableExtra::kable_styling(latex_options = "striped") %>%
kableExtra::collapse_rows(columns = 1)
returns.pca <- princomp(returns[,-21], cor = T)
pc.1 <- returns.pca$loadings[,1]
pc.2 <- returns.pca$loadings[,2]
pcs <- data.frame(pc.1,pc.2,names(pc.1))
colnames(pcs) <- c("PC1","PC2","Index")
pcs$Industry <- c("Indus Metal"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Industrial Chemical"
, "Industrial Chemical"
, "Soft Drinks"
, "Banking"
, "Oil Field Services"
, "Oil Refining"
, "Manufacturing"
, "Industrial Chemical"
, "Banking"
, "Soft Drinks"
, "Manufacuring"
, "Oil Refining"
,"Soft Drinks"
, "Oil Field Services"
, "Banking"
, "Oil Refining"
)
ggplot(data = pcs,mapping = aes(x = PC1,y = PC2,label = Index,color = Industry)) + geom_point() + geom_text(size = 3) + theme_bw() + xlim(c(-0.27,-0.12)) + ylim(c(-0.27,0.6))
plot(returns.pca, xlab = "Component Number", main = " ")
# screeplot(returns.pca)
varcontribution <- returns.pca$sdev^2 / sum(returns.pca$sdev^2)
plot(varcontribution, xlab = "Component Number", ylab = "Variance Contribution", type = "l")
points(varcontribution)
cumvariance <- cumsum(returns.pca$sdev^2) / sum(returns.pca$sdev^2)
plot(cumvariance, xlab = "Component Number", ylab = "Cumulative Variance", type = "l")
points(cumvariance)
abline(h=0.8,lwd = 1.5,col = "red")
abline(v = 8,lwd = 1.5, col = "red")
text(13,0.7, 'Keep 8 Principal Components')
set.seed(200)
returns.scores <- as.data.frame(returns.pca$scores)
returns.scores$VV <- returns$VV
returns.scores$u <- runif(n = nrow(returns.scores), min = 0, max = 1)
train.scores <- subset(returns.scores,u < 0.7)
test.scores <- subset(returns.scores, u >= 0.7)
df <- cbind(Data = c("Training set", "Validation set","Total"), Samples = c(nrow(train.scores),nrow(test.scores),nrow(train.scores) + nrow(test.scores)))
knitr::kable(df,align = c("l","r"),caption = "Training and Validation sampling")
# Linear Regression with PCA
pca.lm <- lm(VV ~ Comp.1 + Comp.2 + Comp.3 + Comp.4 + Comp.5 + Comp.6 + Comp.7 + Comp.8, data = returns.scores)
coef_pca <- round(coef(pca.lm),5)
signs_pca <- ifelse(sign(coef_pca)==1,"+","-")
formula_pca <- as.character(formula(pca.lm))[3]
predictors_pca <- unlist(strsplit(formula_pca, split = "+",fixed = T))
Betas_pca <- paste(abs(coef_pca[2:length(coef_pca)]),"*", predictors_pca)
pcaeqn <- paste("VV = ",paste(coef_pca[1],paste(paste(signs_pca[2:length(signs_pca)], Betas_pca),collapse = " ")))
summary(pca.lm)
vifpc <- as.data.frame(vif(pca.lm))
vifpc$PC <- row.names(vifpc)
colnames(vifpc) <- c("VIF", "PC")
row.names(vifpc) <- NULL
knitr::kable(vifpc[,c("PC","VIF")], caption = "VIF of Principle components")
pca.lm.MAE <- mean(abs(pca.lm$residuals))
pca.test <- predict(pca.lm,newdata = test.scores)
pca.test.MAE <- mean(abs(test.scores$VV - pca.test))
MAEdf <- data.frame(Model = "PCA model", Train.MAE = pca.lm.MAE, Test.MAE = pca.test.MAE)
knitr::kable(MAEdf, caption = "MAE of PCA model")
set.seed(200)
returns$u <- runif(nrow(returns), min = 0 , max = 1)
returns.train <- subset(returns,u >= 0.7)
returns.test <- subset(returns, u < 0.7)
df <- cbind(Data = c("Training set", "Validation set","Total"), Samples = c(nrow(returns.train),nrow(returns.test),nrow(returns.train) + nrow(returns.test)))
knitr::kable(df,align = c("l","r"),caption = "Training and Validation sampling of Raw returns")
# Arbitary model
model.1 <- lm(VV~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns.train)
coef_model.1 <- round(coef(model.1),5)
signs_model.1 <- ifelse(sign(coef_model.1)==1,"+","-")
formula_model.1 <- as.character(formula(model.1))[3]
predictors_model.1 <- unlist(strsplit(formula_model.1, split = "+",fixed = T))
Betas_model.1 <- paste(abs(coef_model.1[2:length(coef_model.1)]),"*", predictors_model.1)
model.1eqn <- paste("VV = ",paste(coef_model.1[1],paste(paste(signs_model.1[2:length(signs_model.1)], Betas_model.1),collapse = " ")))
#model.1 <- lm(VV~ GS+DD+DOW+HON+HUN +JPM + KO + MMM+ XOM, data = returns.train)
summary(model.1)
model1.train.MAE <- mean(abs(model.1$residuals))
model1.test <- predict(model.1, newdata = returns.test)
model1.test.MAE <- mean(abs(model1.test - returns.test$VV))
ArbMAEdf <- data.frame(Model = "Arbitary model", Train.MAE = model1.train.MAE, Test.MAE = model1.test.MAE)
knitr::kable(ArbMAEdf, caption = "MAE of Arbitary model")
# full model
model.2 <- lm(VV~ ., data = returns.train)
coef_model.2 <- round(coef(model.2),5)
signs_model.2 <- ifelse(sign(coef_model.2)==1,"+","-")
formula_model.2 <- as.character(formula(model.2))[3]
predictors_model.2 <- unlist(strsplit(formula_model.2, split = "+",fixed = T))
Betas_model.2 <- paste(abs(coef_model.2[2:length(coef_model.2)]),"*", predictors_model.2)
model.2eqn <- paste("VV = ",paste(coef_model.2[1],paste(paste(signs_model.2[2:length(signs_model.2)], Betas_model.2),collapse = " ")))
models <- data.frame(Models = c("PCA","Arbitary","Full"), Equation = c(pcaeqn,model.1eqn,model.2eqn))
pander::pandoc.table(models, "Model equations",justify = "left",emphasixe.cols = 2)
ModelComp <- rbind(MAEdf,ArbMAEdf,FullMAEdf)
models <- data.frame(Models = c("PCA","Arbitary","Full"), Equation = c(pcaeqn,model.1eqn,model.2eqn))
pander::pandoc.table(models, "Model equations",justify = "left",emphasixe.cols = 2)
ModelComp <- rbind(MAEdf,ArbMAEdf,FullMAEdf)
knitr::kable(ModelComp, caption = "Predictive performance of regression models")
full.lm <- lm(VV ~ ., data = train.scores)
summary(full.lm)
library(MASS)
backward.lm <- stepAIC(full.lm,direction = c('backward'),trace = F)
summary(backward.lm)
vif(backward.lm)
bkward.MAE.train <- mean(abs(backward.lm$residuals))
bkward.test <- predict(backward.lm,newdata = test.scores)
bkward.MAE.test <- mean(abs(bkward.test - test.scores$VV))
bkward.MAE.test
bkward.MAE.train
